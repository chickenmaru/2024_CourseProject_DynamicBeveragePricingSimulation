# -*- coding: utf-8 -*-
"""決策科學期末.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1iUIh6oKglWjbesisOsv1Bdokp99pF18E
"""

import numpy as np
import matplotlib.pyplot as plt

"""Task1：
模擬比賽日的啤酒需求，並提供合理的供應上限

(1) 模擬比賽與觀眾數： 根據三種比賽類型「中信主場」、「中信客場」、「無中信」及其發生機率，模擬當日總觀眾人數
"""

# 模擬各比賽類型的觀眾人數
MATCH_TYPES = ["中信主場", "中信客場", "無中信"]
MATCH_PROB = [0.25, 0.5, 0.25] # 每種類型的發生機率
MATCH_DATA = {
    "中信主場": {"mean": 27705, "std": 9359},
    "中信客場": {"mean": 17636, "std": 4855},
    "無中信": {"mean": 19945, "std": 5058},
}

# 隨機選擇當日比賽類型
np.random.seed(42)
chosen_match = np.random.choice(MATCH_TYPES, p=MATCH_PROB)
match_stats = MATCH_DATA[chosen_match]

# 用Normal distribution模擬當日觀眾總人數
total_visitors = int(np.random.normal(match_stats["mean"], match_stats["std"]))
print(f"今日比賽類型：{chosen_match}")
print(f"模擬當日總人次：{total_visitors} 人")

"""(2) 估算啤酒類需求：假設觀眾中有 10% 的人會購買啤酒。每位購買者的需求量基於正態分布模擬。計算當日總啤酒需求量（毫升）及杯數。"""

# 啤酒需求參數
purchase_probability = 0.1  # 假設10%的觀眾會購買啤酒
average_consumption_per_person = 0.0167  # 每位購買者平均需求量 (公升)
std_dev_consumption = 0.005  # 每位購買者需求標準差 (公升)
ml_per_cup = 250  # 每杯啤酒的容量 (毫升)
max_daily_supply = 5000 * ml_per_cup  # 每日供應上限 (毫升)

# 模擬購買者人數 (Poisson distribution)
total_visitors = max(0, int(np.random.normal(match_stats["mean"], match_stats["std"])))
poisson_lambda = total_visitors * purchase_probability
buyers = np.random.poisson(poisson_lambda)

# 模擬每位購買者的需求量 (Normal distribution)
customer_demand = np.random.normal(average_consumption_per_person, std_dev_consumption, buyers)
customer_demand = customer_demand[customer_demand > 0]  # 只保留正值

# 總銷售量（毫升和杯數）
total_sales_ml = customer_demand.sum() * 1000  # 公升轉換為毫升
total_sales_cups = total_sales_ml / ml_per_cup

# 檢查是否超過供應上限
if total_sales_ml > max_daily_supply:
    print(f"警告：需求超過供應上限！")
    print(f"  總需求量: {total_sales_ml:.2f} 毫升 ({total_sales_cups:.2f} 杯)")
    print(f"  供應上限: {max_daily_supply / ml_per_cup:.0f} 杯")
else:
    print(f"需求在供應上限內。")
    print(f"  總需求量: {total_sales_ml:.2f} 毫升 ({total_sales_cups:.2f} 杯)")

"""(3) 多次模擬與需求分析：重複 1000 次模擬，分析需求分布。計算需求的平均值、標準差，並找出 95% 分位數作為每日供應上限的建議。"""

num_simulations = 1000
simulation_results = []

# 每次模擬中，隨機選擇比賽類型並模擬總人數，且根據購買機率與需求模型計算啤酒總需求量（毫升）
for _ in range(num_simulations):
    chosen_match = np.random.choice(MATCH_TYPES, p=MATCH_PROB)
    match_stats = MATCH_DATA[chosen_match]
    # 模擬當日總人數，確保非負
    total_visitors = max(0, int(np.random.normal(match_stats["mean"], match_stats["std"])))

    poisson_lambda = total_visitors * purchase_probability
    buyers = np.random.poisson(poisson_lambda)

    customer_demand = np.random.normal(average_consumption_per_person, std_dev_consumption, buyers)
    customer_demand = customer_demand[customer_demand > 0]  # 只保留正值
    total_sales_ml = customer_demand.sum() * 1000  # 公升轉毫升

    simulation_results.append(total_sales_ml)

# 分析需求分佈
mean_demand = np.mean(simulation_results)
std_demand = np.std(simulation_results)
# 需求在95%的情況下不會超過該值，作為供應上限的建議
percentile_95 = np.percentile(simulation_results, 95)  # 95% 分位數

print(f"模擬需求的平均值: {mean_demand:.2f} 毫升")
print(f"模擬需求的標準差: {std_demand:.2f} 毫升")
print(f"95% 分位數 (建議供應上限): {percentile_95:.2f} 毫升 ({percentile_95 / ml_per_cup:.0f} 杯)")

# 視覺化需求分佈
plt.hist(simulation_results, bins=30, color='skyblue', edgecolor='black')
plt.axvline(x=percentile_95, color='red', linestyle='--', label='95% 分位數')
plt.title('Total Beer Demand Distribution (1000 Simulations)')
plt.xlabel('Total Sales (ml)')
plt.ylabel('Frequency')
plt.legend()
plt.show()

"""Task2：透過需求推估函數，模擬每天每半小時的啤酒需求，最終得出當日需求量

(1) 比賽類型排程：模擬未來多場比賽類型，限制同類型比賽連續不超過 4 場。
"""

# 定義比賽類型生成函數
def generate_match_schedule(n_games):
    schedule = []
    current_type = None
    consecutive_count = 0

    for _ in range(n_games):
        while True:
            match_type = np.random.choice(MATCH_TYPES, p=MATCH_PROB)
            if match_type != current_type or consecutive_count < 4:
                break

        if match_type == current_type:
            consecutive_count += 1
        else:
            consecutive_count = 1

        current_type = match_type
        schedule.append(match_type)

    return schedule

"""(2) 觀眾人數分配：根據比賽類型模擬總觀眾人數，以半小時為單位，並分配到一天的不同時段（高峰與非高峰時段)。"""

# 定義進場人數生成函數
def generate_audience(match_type, time_slots):
    total_audience = max(0, int(np.random.normal(MATCH_DATA[match_type]['mean'], MATCH_DATA[match_type]['std'])))

    # 將人數分配到 12~22 時段
    major_slots = time_slots[3:10]  # 高峰時段
    minor_slots = time_slots[:3] + time_slots[10:]

    major_audience = int(total_audience * 0.8)
    minor_audience = total_audience - major_audience

    major_distribution = np.random.dirichlet(np.ones(len(major_slots))) * major_audience
    minor_distribution = np.random.dirichlet(np.ones(len(minor_slots))) * minor_audience

    audience_distribution = np.zeros(len(time_slots))
    audience_distribution[3:10] = major_distribution
    audience_distribution[:3] = minor_distribution[:3]
    audience_distribution[10:] = minor_distribution[3:]

    return audience_distribution.astype(int)

"""Task3：模擬不同類型酒類的需求模型和定價策略，並計算利潤"""

import numpy as np

# 飲料種類和屬性設定
DRINK_CATEGORIES = {
    "無酒精飲料": 3,
    "啤酒": 5,
    "調酒": 12
}
DRINK_TYPES = [f"{category}{i+1}" for category, count in DRINK_CATEGORIES.items() for i in range(count)]

# 定義每種酒類的成本與初始價格
cost_per_unit = {"log": 0.2, "exp": 0.1, "linear": 0.4}
initial_prices = {"log": 0.5, "exp": 0.2, "linear": 0.9}

# 定義每種酒類的價格範圍
price_ranges = {
    "log": np.linspace(0.3, 0.6, 100),
    "exp": np.linspace(0.1, 0.35, 100),
    "linear": np.linspace(0.5, 2.0, 100),
}

## 需求模型參數生成
parameters = []

# 生成log模型參數（啤酒）
for _ in range(3):  # 啤酒的數量
    a = np.random.uniform(1.5, 6)
    b = np.random.uniform(8, 25)
    parameters.append(("log", a, b))

# 生成exp模型參數（無酒精飲料）
for _ in range(5):  # 無酒精飲料的數量
    c = np.random.uniform(0.3, 1.0) # 調低需求基數，讓Demand不要那麼高
    d = np.random.uniform(0.5, 1.0)
    parameters.append(("exp", c, d))

# 生成linear模型參數（調酒）
for _ in range(12):  # 調酒的數量
    e = np.random.uniform(1.0, 2) # 顯著降低基數，讓Demand不要那麼高
    f = np.random.uniform(2.5, 4.0) # 提高價格敏感度，讓Demand不要那麼高
    parameters.append(("linear", e, f))

# 定義需求函數
def log_demand(a, b, price):
    """Logarithmic demand function."""
    return a * np.log(np.maximum(1e-5, b - price))

def exp_demand(c, d, price):
    """Exponential demand function."""
    return c * np.exp(-d * price)

def linear_demand(e, f, price):
    """Linear demand function."""
    return np.maximum(0, e - f * price)

# 酒類與需求模型的對應關係
DRINK_MODELS = {
    "無酒精飲料": "exp",
    "啤酒": "log",
    "調酒": "linear"
}
drink_demand_types = {
    f"{category}{i+1}": DRINK_MODELS[category]
    for category, count in DRINK_CATEGORIES.items()
    for i in range(count)
}

# 確認每種酒品對應其需求模型的參數
parameter_mapping = {drink: parameters[i] for i, drink in enumerate(DRINK_TYPES)}

# 利潤計算函數
def calculate_profit(price, demand, cost):
    return (price - cost) * demand * 1000

# 漲幅上限(漲停板)、跌幅下限(跌停板)
UP_LIMIT = 1.2
DOWN_LIMIT = 0.3

# 達到銷售標準，價格漲跌的趴數
UP_RATE = 0.01
DOWN_RATE = 0.02

"""Task4：

靜態定價策略

- 每種類型的酒類價格固定不變，計算需求、銷售和利潤。

- 考慮供應限制，分別為**三大酒類的設置每日供應上限**，確保銷售量不超過供應上限。

- 根據比賽類型和觀眾分布調整需求模型，模擬更貼近現實的需求波動。
"""

time_slots_per_day = 26
DAILY_BEER_SUPPLY = 60432.41 * time_slots_per_day  # 啤酒
DAILY_NON_ALCOHOLIC_SUPPLY = DAILY_BEER_SUPPLY * 0.7  # 無酒精飲料
DAILY_PURE_ALCOHOL_SUPPLY = DAILY_BEER_SUPPLY * 0.5  # 調酒

def simulate_static_pricing(n_days, time_slots_per_day, parameters, cost_per_unit, initial_prices):
    # 初始化每日供應上限
    daily_supplies = {
        "無酒精飲料": DAILY_NON_ALCOHOLIC_SUPPLY,
        "啤酒": DAILY_BEER_SUPPLY,
        "調酒": DAILY_PURE_ALCOHOL_SUPPLY,
    }

    # profit、sales、demands、static_results、individual_supplies變數初始化
    total_profit = 0
    all_sales = {drink: [] for drink in DRINK_TYPES}
    all_demands = {drink: [] for drink in DRINK_TYPES}
    all_profits = {drink: 0 for drink in DRINK_TYPES}
    static_results = {}
    individual_supplies = {drink: 0 for drink in DRINK_TYPES}

    # 比賽日程
    schedule = generate_match_schedule(n_days)

    for day in range(n_days):
            match_type = schedule[day]
            audience_distribution = generate_audience(match_type, list(range(time_slots_per_day)))

            # 對每一天的每個時段進行模擬
            for t in range(time_slots_per_day):
                for drink in DRINK_TYPES:
                    # 確定酒類類別，因同一酒類共用一個供應上限
                    if "無酒精飲料" in drink:
                        category = "無酒精飲料"
                    elif "啤酒" in drink:
                        category = "啤酒"
                    elif "調酒" in drink:
                        category = "調酒"
                    else:
                        raise ValueError(f"未知飲料類型: {drink}")

                    # 需求模型、價格、成本和需求參數
                    demand_type = drink_demand_types[drink]
                    price = initial_prices[demand_type]
                    cost = cost_per_unit[demand_type]
                    params = parameters[DRINK_TYPES.index(drink)]

                    # 根據需求類型計算需求量，並考慮隨機需求波動
                    random_demand_factor = np.random.uniform(0.98, 1.02)
                    if demand_type == "log":
                        _, a, b = params
                        demand = max(0, log_demand(a, b, price) * random_demand_factor)
                    elif demand_type == "exp":
                        _, c, d = params
                        demand = max(0, exp_demand(c, d, price) * random_demand_factor)
                    elif demand_type == "linear":
                        _, e, f = params
                        demand = max(0, linear_demand(e, f, price) * random_demand_factor)
                    else:
                        raise ValueError(f"未知需求類型: {demand_type}")

                    # 因為Normal Distribution導致生成的需求可能為負數，故用max(0,value)，將Demand調整至0
                    # 基於一天內不同時段的觀眾分布調整需求
                    audience_count = audience_distribution[t]
                    adjusted_demand = sum(
                        max(0, log_demand(*params[1:], price)) if demand_type == "log" else
                        max(0, exp_demand(*params[1:], price)) if demand_type == "exp" else
                        max(0, linear_demand(*params[1:], price))
                        for _ in range(audience_count)
                    )

                    # 若該時段的該類酒品的Demand為0，隨機從100毫升至2000毫升，生成一數值作為Demand
                    if demand == 0:
                        demand = np.random.uniform(0.1, 2)  # Small random demand

                    # 將需求單位從公升(l)轉換為毫升（ml）
                    adjusted_demand = max(0, demand * 1000)

                    ## 計算銷售量與利潤
                    # 銷售量受到每日供應上限的限制
                    sales = min(adjusted_demand, daily_supplies[category])
                    daily_supplies[category] -= sales
                    individual_supplies[drink] += sales

                    # 計算該時段的利潤，並累積到總利潤中
                    profit = sales * (price - cost)
                    all_profits[drink] += profit
                    total_profit += profit

                    # 儲存結果
                    all_demands[drink].append(adjusted_demand)
                    all_sales[drink].append(sales)

                    # print出每日、每半小時的詳細信息，包括需求、銷售量、剩餘供應和利潤
                    print(
                        f"Day {day + 1}, Time Slot {t + 1}, Drink: {drink}, "
                        f"Demand: {adjusted_demand:.2f} ml, Sales: {sales:.2f} ml, "
                        f"Category Supply Remaining: {daily_supplies[category]:.2f} ml, "
                        f"Individual Supply Sold: {individual_supplies[drink]:.2f} ml, "
                        f"Price: {price:.2f}/ml, Cost: {cost:.2f}/ml, Profit: {profit:.2f}"
                    )

    # 計算靜態定價模擬的總利潤
    print(f"\nTotal Profit from Static Pricing: {total_profit:.2f}")
    return all_profits, all_sales, all_demands, daily_supplies, schedule

# 執行模擬靜態定價
all_profits, all_sales, all_demands, daily_supplies, schedule = simulate_static_pricing(
    n_days=1, # 模擬1天的銷售情況
    time_slots_per_day=26, # 一天有26個時段（每半小時一個時段，共13小時）
    parameters=parameters, # 需求模型參數（log, exp, linear模型參數）
    cost_per_unit=cost_per_unit,
    initial_prices=initial_prices
)

# 計算靜態定價的總利潤
static_total_profit = sum(all_profits.values())

# 顯示結果
print("Static Pricing Results:")
for drink in DRINK_TYPES:
    total_sales = sum(all_sales[drink])
    total_demand = sum(all_demands[drink])
    print(f"{drink}:  Total Sales={total_sales:.2f} ml, Total Demand={total_demand:.2f} ml, Total Profit={all_profits[drink]:.2f}")

print(f"\nTotal Profit from Static Pricing: {static_total_profit:.2f}")

"""Task5：

動態定價策略

- 每種類型的酒類價格隨著需求函數變動，計算需求、銷售和利潤。

- 考慮供應限制，分別為**三大酒類的設置每日供應上限**，確保銷售量不超過供應上限。

- 根據比賽類型和觀眾分布調整需求模型，模擬更貼近現實的需求波動。

- **動態更新價格**，當累積銷售量達到1000毫升，價格上漲。若無需求，價格下降。
"""

# 每日供應上限 (將半小時的供應量乘以每天的時間段數量)，以三大類酒類分別設定供給上限
time_slots_per_day = 26
DAILY_BEER_SUPPLY = 60432.41 * time_slots_per_day  # 啤酒
DAILY_NON_ALCOHOLIC_SUPPLY = DAILY_BEER_SUPPLY * 0.7  # 無酒精飲料
DAILY_PURE_ALCOHOL_SUPPLY = DAILY_BEER_SUPPLY * 0.5  # 調酒

def simulate_dynamic_pricing(n_days, time_slots_per_day, parameters, cost_per_unit, initial_prices):
    schedule = generate_match_schedule(n_days)
    all_prices = {drink: [] for drink in DRINK_TYPES}
    all_demands = {drink: [] for drink in DRINK_TYPES}
    all_sales = {drink: [] for drink in DRINK_TYPES}
    # 記錄酒品剩餘的每日供應量
    all_supplies = {drink: 0 for drink in DRINK_TYPES}
    all_profits = {drink: 0 for drink in DRINK_TYPES}
    total_profit = 0
    price_history = {drink: [] for drink in DRINK_TYPES}

    for day in range(n_days):
        match_type = schedule[day]
        audience_distribution = generate_audience(match_type, list(range(time_slots_per_day)))

        daily_prices = {drink: initial_prices[drink_demand_types[drink]] for drink in DRINK_TYPES}  # 每日初始價格
        cumulative_sales = {drink: 0 for drink in DRINK_TYPES}  # 累積銷售量
        individual_supplies = {drink: 0 for drink in DRINK_TYPES}

        # 初始化每日供應上限
        daily_supplies = {
        "無酒精飲料": DAILY_NON_ALCOHOLIC_SUPPLY,
        "啤酒": DAILY_BEER_SUPPLY,
        "調酒": DAILY_PURE_ALCOHOL_SUPPLY,
    }

        # 對每一天的每個時段進行模擬
        for t in range(time_slots_per_day):
            for drink in DRINK_TYPES:
                # 同一酒類共用一個供應上限
                if "無酒精飲料" in drink:
                    category = "無酒精飲料"
                elif "啤酒" in drink:
                    category = "啤酒"
                elif "調酒" in drink:
                    category = "調酒"
                else:
                    raise ValueError(f"未知飲料類型: {drink}")

                # 需求模型、價格、成本和需求參數
                demand_type = drink_demand_types[drink]
                current_price = daily_prices[drink]
                cost = cost_per_unit[demand_type]
                params = parameters[DRINK_TYPES.index(drink)]

                # 根據需求類型計算需求量，並考慮隨機需求波動
                random_demand_factor = np.random.uniform(0.98, 1.02)
                if demand_type == "log":
                  _, a, b = params
                  demand = max(0,log_demand(a, b, current_price) * random_demand_factor)
                elif demand_type == "exp":
                  _, c, d = params
                  demand = max(0,exp_demand(c, d, current_price) * random_demand_factor)
                elif demand_type == "linear":
                  _, e, f = params
                  demand = max(0,linear_demand(e, f, current_price) * random_demand_factor)


                # 因為Normal Distribution導致生成的需求可能為負數，故用max(0,value)，將Demand調整至0
                # 基於一天內不同時段的觀眾分布調整需求
                audience_count = audience_distribution[t]
                adjusted_demand = sum(
                  max(0, log_demand(*params[1:], current_price)) if demand_type == "log" else
                  max(0, exp_demand(*params[1:], current_price)) if demand_type == "exp" else
                  max(0, linear_demand(*params[1:], current_price))
                  for _ in range(audience_count)
              )
                # 若該時段的該類酒品的Demand為0，隨機從100毫升至2000毫升，生成一數值作為Demand
                if adjusted_demand == 0:
                  adjusted_demand = np.random.uniform(0.1, 2)

                adjusted_demand = adjusted_demand * 1000  # 轉換為毫升
                sales = min(adjusted_demand, daily_supplies[category]) # 确保銷售量不超過剩餘供给量
                daily_supplies[category] -= sales # 更新剩餘供應量

                # 計算銷售量與利潤，銷售量受到每日供應上限的限制
                last_sales = max(0, adjusted_demand)
                all_sales[drink].append(last_sales)
                all_demands[drink].append(adjusted_demand)
                individual_supplies[drink] += sales

                # 計算該時段的利潤，並累積到總利潤中
                profit = sales * (current_price - cost)
                all_profits[drink] += profit
                total_profit += profit

                ## 更新價格
                cumulative_sales[drink] += last_sales
                # 若累積銷售量達到1000毫升，價格上漲。若無需求，價格下降。
                if cumulative_sales[drink] >= 1000:
                    current_price *= (1 + UP_RATE)
                    cumulative_sales[drink] = 0  # 重置累積銷售量
                elif last_sales == 0:  # 無需求
                    current_price *= (1 - DOWN_RATE)
                # 限制價格範圍
                current_price = max(DOWN_LIMIT, min(UP_LIMIT, current_price))

                # 更新與紀錄價格
                daily_prices[drink] = current_price
                all_prices[drink].append(current_price)
                price_history[drink].append(current_price)

                # print出動態定價策略下的利潤、價格變化、需求、銷售和供應情況
                print(
                  f"Day {day + 1}, Time Slot {t + 1}, Drink: {drink}, "
                  f"Demand: {adjusted_demand:.2f} ml, Sales: {sales:.2f} ml, "
                  f"Category Supply Remaining: {daily_supplies[category]:.2f} ml, "
                  f"Individual Supply Sold: {individual_supplies[drink]:.2f} ml, "
                  f"Price: {current_price:.2f}, Profit: {profit:.2f}"
              )

    print(f"\nTotal Profit from Dynamic Pricing: {total_profit:.2f}")
    return all_profits, price_history, all_prices, all_demands, all_sales, daily_supplies, schedule

# 執行動態定價模擬
dynamic_results, price_history, all_prices, all_demands, all_sales, all_supplies, schedule = simulate_dynamic_pricing(
    n_days=1,
    time_slots_per_day=26,
    parameters=parameters,
    cost_per_unit=cost_per_unit,
    initial_prices=initial_prices
)

# 計算動態定價策略下的總利潤
total_dynamic_profit = sum(dynamic_results.values())

# 輸出動態定價結果
print("\nDynamic Pricing Results:")
for drink, profit in dynamic_results.items():
    print(f"{drink}: {profit:.2f}")
print(f"Total Dynamic Profit: {total_dynamic_profit:.2f}")

# 動態定價策略下的價格變化
plt.figure(figsize=(12, 6))
for drink, prices in price_history.items():
    plt.plot(prices, label=drink)
plt.title("Price Changes Over Time (30-Minute Intervals)")
plt.xlabel("Time Interval")
plt.ylabel("Price")
plt.legend(title="Drinks", bbox_to_anchor=(1.05, 1), loc='upper left')
plt.grid(True)
plt.tight_layout()
plt.show()

"""Task6：

在動態定價策略下，考慮**不同酒類之間的價格交互影響**，來調整需求和銷售量，進而影響利潤。

- 提升模型真實性，反映消費者選擇的相對性。
"""

# 三大類酒類分別設定供給上限
time_slots_per_day = 26
DAILY_BEER_SUPPLY = 60432.41 * time_slots_per_day  # 啤酒
DAILY_NON_ALCOHOLIC_SUPPLY = DAILY_BEER_SUPPLY * 0.7  # 無酒精飲料
DAILY_PURE_ALCOHOL_SUPPLY = DAILY_BEER_SUPPLY * 0.5  # 調酒

def simulate_dynamic_pricing_with_interactions(n_days, time_slots_per_day, parameters, cost_per_unit, initial_prices):
    schedule = generate_match_schedule(n_days)
    all_prices = {drink: [] for drink in DRINK_TYPES}
    all_demands = {drink: [] for drink in DRINK_TYPES}
    all_sales = {drink: [] for drink in DRINK_TYPES}
    all_supplies = {drink: 0 for drink in DRINK_TYPES}
    all_profits = {drink: 0 for drink in DRINK_TYPES}
    total_profit = 0
    price_history = {drink: [] for drink in DRINK_TYPES}
    individual_supplies = {drink: 0 for drink in DRINK_TYPES}
    cumulative_sales = {drink: 0 for drink in DRINK_TYPES}

    for day in range(n_days):
        match_type = schedule[day]
        audience_distribution = generate_audience(match_type, list(range(time_slots_per_day)))

        daily_prices = {
          drink: initial_prices[drink_demand_types[drink]]
          for drink in DRINK_TYPES
      }

        # 交互影響矩陣 - 每種酒類對其他酒類的需求影響通過交互係數
        # 正值（互補性），如當「啤酒」價格提高，可能會促進「無酒精飲料」需求（係數 0.05）
        # 負值（競爭性），如當「啤酒」價格提高，可能會降低「調酒」需求（係數 -0.1）
        interaction_coefficients = {
            "無酒精飲料": {"啤酒": 0.1, "調酒": -0.05},
            "啤酒": {"無酒精飲料": 0.05, "調酒": -0.1},
            "調酒": {"無酒精飲料": -0.05, "啤酒": 0.1},
        }

        daily_supplies = {
        "無酒精飲料": DAILY_NON_ALCOHOLIC_SUPPLY,
        "啤酒": DAILY_BEER_SUPPLY,
        "調酒": DAILY_PURE_ALCOHOL_SUPPLY,
    }

        for t in range(time_slots_per_day):
            for drink in DRINK_TYPES:
                if "無酒精飲料" in drink:
                    category = "無酒精飲料"
                elif "啤酒" in drink:
                    category = "啤酒"
                elif "調酒" in drink:
                    category = "調酒"
                else:
                    raise ValueError(f"未知飲料類型: {drink}")

                demand_type = drink_demand_types[drink]
                current_price = daily_prices[drink]
                cost = cost_per_unit[demand_type]
                params = parameters[DRINK_TYPES.index(drink)]

                # 根據需求類型計算需求量，並考慮隨機需求波動
                random_demand_factor = np.random.uniform(0.98, 1.02)
                if demand_type == "log":
                  _, a, b = params
                  demand = max(0,log_demand(a, b, current_price) * random_demand_factor) # max(0,value) -> 避免Demand出現負數
                elif demand_type == "exp":
                  _, c, d = params
                  demand = max(0,exp_demand(c, d, current_price) * random_demand_factor)
                elif demand_type == "linear":
                  _, e, f = params
                  demand = max(0,linear_demand(e, f, current_price) * random_demand_factor)

                # 因為Normal Distribution導致生成的需求可能為負數，故用max(0,value)，將Demand調整至0
                # 基於一天內不同時段的觀眾分布調整需求
                audience_count = audience_distribution[t]
                adjusted_demand = sum(
                  max(0, log_demand(*params[1:], current_price)) if demand_type == "log" else
                  max(0, exp_demand(*params[1:], current_price)) if demand_type == "exp" else
                  max(0, linear_demand(*params[1:], current_price))
                  for _ in range(audience_count)
              )

                # 若該時段的該類酒品的Demand為0，隨機從100毫升至2000毫升，生成一數值作為Demand
                if adjusted_demand == 0:
                  adjusted_demand = np.random.uniform(0.1, 2)

                ## 不同酒類間的交互影響
                interaction_effect = sum(
                    interaction_coefficients[category].get(other_category, 0) * daily_prices[other_drink]
                    for other_drink, other_category in zip(DRINK_TYPES, ["無酒精飲料", "啤酒", "調酒"])
                    if other_drink != drink
                )
                adjusted_demand = max(0, adjusted_demand + interaction_effect)
                adjusted_demand = adjusted_demand * 1000  # 轉換為毫升

                sales = min(adjusted_demand, daily_supplies[category]) # 确保銷售量不超過剩餘供给量
                daily_supplies[category] -= sales # 更新剩餘供應量

                # 計算需求與銷售量
                last_sales = max(0, adjusted_demand)
                all_sales[drink].append(last_sales)
                all_demands[drink].append(adjusted_demand)
                individual_supplies[drink] += sales

                # 利潤基於實際銷售量計算
                profit = sales * (current_price - cost)
                all_profits[drink] += profit
                total_profit += profit

                # 更新價格
                cumulative_sales[drink] += last_sales
                if cumulative_sales[drink] >= 1000:
                    current_price *= (1 + UP_RATE)
                    cumulative_sales[drink] = 0  # 重置累積銷售量
                elif last_sales == 0:
                    current_price *= (1 - DOWN_RATE)

                # 限制價格範圍
                current_price = max(DOWN_LIMIT, min(UP_LIMIT, current_price))

                # 更新價格記錄
                daily_prices[drink] = current_price
                all_prices[drink].append(current_price)
                price_history[drink].append(current_price)

                # 價格與需求變化
                print(
                  f"Day {day + 1}, Time Slot {t + 1}, Drink: {drink}, "
                  f"Interaction Effect: {interaction_effect:.2f} ml, "
                  f"Adjusted Demand: {adjusted_demand:.2f} ml, "
                  f"Sales: {sales:.2f} ml, "
                  f"Category Supply Remaining: {daily_supplies[category]:.2f} ml, "
                  f"Price: {current_price:.2f}, "
                  f"Profit: {profit:.2f}"
              )
    print(f"\nTotal Profit from Dynamic Pricing: {total_profit:.2f}")
    return all_profits, price_history, all_prices, all_demands, all_sales, daily_supplies, schedule

# 執行動態定價模擬
dynamic_results, price_history, all_prices, all_demands, all_sales, daily_supplies, schedule = simulate_dynamic_pricing_with_interactions(
    n_days=1,
    time_slots_per_day=26,
    parameters=parameters,
    cost_per_unit=cost_per_unit,
    initial_prices=initial_prices
)

# 計算總利潤
total_dynamic_profit = sum(dynamic_results.values())

def plot_price_and_sales(price_history, all_sales, daily_supplies, up_limit=None, down_limit=None, total_sales_limit=None):
    import matplotlib.pyplot as plt
    import numpy as np

    plt.figure(figsize=(12, 6))
    for drink, prices in price_history.items():
        plt.plot(prices, label=f"{drink} Price")

    if up_limit is not None:
        plt.axhline(y=up_limit, color='g', linestyle='--', label='Price Upper Limit')
    if down_limit is not None:
        plt.axhline(y=down_limit, color='b', linestyle='--', label='Price Lower Limit')

    plt.title("Price Changes Over Time (30-Minute Intervals)")
    plt.xlabel("Time Interval")
    plt.ylabel("Price")
    plt.legend(title="Legend", bbox_to_anchor=(1.05, 1), loc='upper left')
    plt.grid(True)
    plt.tight_layout()
    plt.show()

    # 計算每個時間段的總銷售量
    total_sales_per_period = np.sum(
        np.array([sales for sales in all_sales.values()]), axis=0
    )

    # 總銷售量變化
    plt.figure(figsize=(12, 6))
    plt.plot(total_sales_per_period, label="Total Sales Per Period", color='orange')
    if total_sales_limit is not None:
        plt.axhline(y=total_sales_limit, color='r', linestyle='--', label='Total Sales Limit')

    plt.title("Total Sales Over Time")
    plt.xlabel("Time Interval")
    plt.ylabel("Total Sales (ml)")
    plt.legend(loc='upper left')
    plt.grid(True)
    plt.tight_layout()
    plt.show()

# 價格變化和銷售量變化
plot_price_and_sales(
    price_history,
    all_sales,
    daily_supplies,
    up_limit=1.2,  # 模擬中的價格上限
    down_limit=0.25  # 模擬中的價格下限
)

"""延伸策略"""

import numpy as np
import matplotlib.pyplot as plt

# 基本參數設定
np.random.seed(42)
TIME_SLOT_DURATION = 15
HOURS_PER_DAY = 13
time_slots_per_day = HOURS_PER_DAY * (60 // TIME_SLOT_DURATION)

# 比賽相關設定
MATCH_TYPES = ["中信主場", "中信客場", "無中信"]
MATCH_PROB = [0.25, 0.5, 0.25]
MATCH_DATA = {
    "中信主場": {"mean": 27705, "std": 9359},
    "中信客場": {"mean": 17636, "std": 4855},
    "無中信": {"mean": 19945, "std": 5058},
}
IS_MATCH_DAY_PROB = 0.6

# 飲料相關設定
DRINK_CATEGORIES = {
    "無酒精飲料": 5,
    "啤酒": 3,
    "調酒": 12
}
DRINK_TYPES = [
    f"{category}{i+1}"
    for category, count in DRINK_CATEGORIES.items()
    for i in range(count)
]

initial_prices = {
    # 無酒精飲料 (5)
    "無酒精飲料1": 0.20,
    "無酒精飲料2": 0.23,
    "無酒精飲料3": 0.25,
    "無酒精飲料4": 0.22,
    "無酒精飲料5": 0.24,

    # 啤酒 (3)
    "啤酒1": 0.50,
    "啤酒2": 0.48,
    "啤酒3": 0.55,

    # 調酒 (12)
    "調酒1": 0.90,
    "調酒2": 0.85,
    "調酒3": 0.92,
    "調酒4": 1.00,
    "調酒5": 1.05,
    "調酒6": 0.88,
    "調酒7": 0.93,
    "調酒8": 0.82,
    "調酒9": 0.97,
    "調酒10": 1.10,
    "調酒11": 0.95,
    "調酒12": 1.02,
}

# 成本設定 (依需求模型)
cost_per_unit = {"log": 0.2, "exp": 0.1, "linear": 0.4}

# 需求模型參數生成
parameters_log = []
parameters_exp = []
parameters_linear = []

# 生成 log 模型參數（啤酒）
for _ in range(DRINK_CATEGORIES["啤酒"]):
    a = np.random.uniform(1.5, 6)
    b = np.random.uniform(8, 25)
    parameters_log.append(("log", a, b))

# 生成 exp 模型參數（無酒精飲料）
for _ in range(DRINK_CATEGORIES["無酒精飲料"]):
    c = np.random.uniform(0.3, 1.0)
    d = np.random.uniform(0.5, 1.0)
    parameters_exp.append(("exp", c, d))

# 生成 linear 模型參數（調酒）
for _ in range(DRINK_CATEGORIES["調酒"]):
    e = np.random.uniform(1.0, 2)
    f = np.random.uniform(2.5, 4.0)
    parameters_linear.append(("linear", e, f))

# 需求函數定義
def log_demand(a, b, price):
    return a * np.log(np.maximum(1e-5, b - price))

def exp_demand(c, d, price):
    return c * np.exp(-d * price)

def linear_demand(e, f, price):
    return np.maximum(0, e - f * price)

# 酒類與需求模型的對應
DRINK_MODELS = {
    "無酒精飲料": "exp",
    "啤酒": "log",
    "調酒": "linear"
}
drink_demand_types = {
    f"{category}{i+1}": DRINK_MODELS[category]
    for category, count in DRINK_CATEGORIES.items()
    for i in range(count)
}

# 參數映射設定
parameter_mapping = {}
log_index = exp_index = linear_index = 0

for drink in DRINK_TYPES:
    if "啤酒" in drink:
        parameter_mapping[drink] = parameters_log[log_index]
        log_index += 1
    elif "無酒精飲料" in drink:
        parameter_mapping[drink] = parameters_exp[exp_index]
        exp_index += 1
    elif "調酒" in drink:
        parameter_mapping[drink] = parameters_linear[linear_index]
        linear_index += 1

# 定價相關常數
UP_LIMIT = 1.2
DOWN_LIMIT = 0.3
UP_RATE = 0.01
DOWN_RATE = 0.02

# 供應上限設定
DAILY_BEER_SUPPLY = 60432.41 * time_slots_per_day
DAILY_NON_ALCOHOLIC_SUPPLY = DAILY_BEER_SUPPLY * 0.7
DAILY_PURE_ALCOHOL_SUPPLY = DAILY_BEER_SUPPLY * 0.5

def calculate_profit(price, demand, cost):
    return (price - cost) * demand * 1000

def generate_match_schedule(n_games):
    """
    事先產生一個比賽賽程，可避免連續同類比賽超過 4 天。
    但在本程式範例中未被實際呼叫，如需使用可自行整合。
    """
    schedule = []
    current_type = None
    consecutive_count = 0

    for _ in range(n_games):
        while True:
            match_type = np.random.choice(MATCH_TYPES, p=MATCH_PROB)
            if match_type != current_type or consecutive_count < 4:
                break

        if match_type == current_type:
            consecutive_count += 1
        else:
            consecutive_count = 1

        current_type = match_type
        schedule.append(match_type)

    return schedule

def generate_audience(match_type, time_slots):
    total_audience = max(
        0,
        int(np.random.normal(MATCH_DATA[match_type]['mean'], MATCH_DATA[match_type]['std']))
    )

    major_slots = time_slots[3:10]
    minor_slots = list(range(0, 3)) + list(range(10, len(time_slots)))

    major_audience = int(total_audience * 0.8)
    minor_audience = total_audience - major_audience

    major_distribution = np.random.dirichlet(np.ones(len(major_slots))) * major_audience
    minor_distribution = np.random.dirichlet(np.ones(len(minor_slots))) * minor_audience

    audience_distribution = np.zeros(len(time_slots))
    for i, slot in enumerate(major_slots):
        audience_distribution[slot] = major_distribution[i]
    for i, slot in enumerate(minor_slots):
        audience_distribution[slot] = minor_distribution[i]

    return audience_distribution.astype(int)

def get_demand(demand_type, params, price, discount_multiplier=1.0):
    if demand_type == "log":
        _, a, b = params
        return max(0, log_demand(a, b, price)) * discount_multiplier
    elif demand_type == "exp":
        _, c, d = params
        return max(0, exp_demand(c, d, price)) * discount_multiplier
    elif demand_type == "linear":
        _, e, f = params
        return max(0, linear_demand(e, f, price)) * discount_multiplier
    else:
        raise ValueError(f"未知需求類型: {demand_type}")

def simulate_dynamic_pricing_with_discounts(
    n_days,
    time_slots_per_day,
    parameter_mapping,
    cost_per_unit,
    initial_prices,
    discount_upper_limit
):
    schedule = []
    all_prices = {drink: [] for drink in DRINK_TYPES}
    all_demands = {drink: [] for drink in DRINK_TYPES}
    all_sales = {drink: [] for drink in DRINK_TYPES}
    all_profits = {drink: 0 for drink in DRINK_TYPES}
    total_profit = 0
    price_history = {drink: [] for drink in DRINK_TYPES}

    for day in range(n_days):
        # 決定是否是比賽日
        is_match_day = np.random.rand() < IS_MATCH_DAY_PROB
        if is_match_day:
            match_type = np.random.choice(MATCH_TYPES, p=MATCH_PROB)
            schedule.append(match_type)
            audience_distribution = generate_audience(match_type, list(range(time_slots_per_day)))
        else:
            schedule.append("非比賽日")
            match_type = "無中信"
            audience_distribution = generate_audience(match_type, list(range(time_slots_per_day)))

        # 每日可用供應量
        daily_supplies = {
            "無酒精飲料": DAILY_NON_ALCOHOLIC_SUPPLY,
            "啤酒": DAILY_BEER_SUPPLY,
            "調酒": DAILY_PURE_ALCOHOL_SUPPLY,
        }
        # 為每款飲料設定「當天」的初始價格
        daily_prices = {drink: initial_prices[drink] for drink in DRINK_TYPES}
        cumulative_sales = {drink: 0 for drink in DRINK_TYPES}

        # 決定折扣時段（若是比賽日）
        if is_match_day:
            match_duration_minutes = int(np.random.gamma(shape=5, scale=15))
            match_duration_slots = max(1, match_duration_minutes // TIME_SLOT_DURATION)
            match_duration_slots = min(match_duration_slots, time_slots_per_day - 5)

            latest_start_slot = time_slots_per_day - (match_duration_slots + 4)
            match_start_slot = np.random.randint(0, latest_start_slot + 1) if latest_start_slot > 0 else 0
            match_end_slot = match_start_slot + match_duration_slots

            home_team_scores = np.random.poisson(1.2, match_duration_slots)
            total_home_points = home_team_scores.sum()

            discount_percentage = min(total_home_points * 0.01, discount_upper_limit)
            discount_multiplier = 1 - discount_percentage

            # 這裡可根據需求調整折扣起訖時段
            # 例如只在比賽結束後 1 小時:
            discount_start_slot = match_end_slot
            discount_end_slot = match_end_slot + 4

            discount_slots = range(
                discount_start_slot,
                min(discount_end_slot, time_slots_per_day)
            )
        else:
            discount_slots = []
            discount_multiplier = 1.0

        # 逐時段模擬銷售 & 調價
        for t in range(time_slots_per_day):
            current_discount_multiplier = discount_multiplier if t in discount_slots else 1.0

            for drink in DRINK_TYPES:
                # 判斷品項類別（對應哪一個 daily_supplies key）
                if "無酒精飲料" in drink:
                    category = "無酒精飲料"
                elif "啤酒" in drink:
                    category = "啤酒"
                elif "調酒" in drink:
                    category = "調酒"
                else:
                    raise ValueError(f"未知飲料類型: {drink}")

                demand_type = drink_demand_types[drink]
                # 以「每款飲料」的初始價格為基準
                base_price = initial_prices[drink]
                current_price = daily_prices[drink]

                # 若在折扣時段，使用 (base_price * discount_multiplier)
                if t in discount_slots:
                    current_price = base_price * discount_multiplier
                else:
                    # 漲價條件：該飲料在當日前累積賣超過 1000 ml
                    if cumulative_sales[drink] >= 0:
                        current_price *= (1 + UP_RATE)
                        cumulative_sales[drink] = 0
                    # 降價條件：上一個時段銷量為 0
                    elif all_sales[drink] and all_sales[drink][-1] == 0:
                        current_price *= (1 - DOWN_RATE)

                # 夾在上下限內
                current_price = max(DOWN_LIMIT, min(UP_LIMIT, current_price))
                daily_prices[drink] = current_price
                all_prices[drink].append(current_price)
                price_history[drink].append(current_price)

                # 計算需求
                params = parameter_mapping[drink]
                demand = get_demand(demand_type, params, current_price, current_discount_multiplier)

                # 根據當時段觀眾數，調整需求
                audience_count = audience_distribution[t]
                adjusted_demand = demand * audience_count
                adjusted_demand_ml = max(0, adjusted_demand * 1000)

                # 實際銷售量（受限於供應量）
                sales_ml = min(adjusted_demand_ml, daily_supplies[category])
                daily_supplies[category] -= sales_ml
                all_sales[drink].append(sales_ml)

                # 計算利潤
                profit = calculate_profit(
                    current_price,
                    sales_ml / 1000,
                    cost_per_unit[demand_type]
                )
                all_profits[drink] += profit
                total_profit += profit

                # 累積銷售量，用於「漲價門檻」
                cumulative_sales[drink] += sales_ml

    return (
        all_profits,
        price_history,
        all_prices,
        all_demands,
        all_sales,
        daily_supplies,
        schedule,
        total_profit
    )

def find_best_discount_upper_limit(
    n_days,
    time_slots_per_day,
    parameter_mapping,
    cost_per_unit,
    initial_prices,
    discount_upper_limits
):
    results = {}
    for discount_upper_limit in discount_upper_limits:
        dynamic_results, price_history, all_prices, all_demands, all_sales, daily_supplies, schedule, total_profit = \
            simulate_dynamic_pricing_with_discounts(
                n_days=n_days,
                time_slots_per_day=time_slots_per_day,
                parameter_mapping=parameter_mapping,
                cost_per_unit=cost_per_unit,
                initial_prices=initial_prices,
                discount_upper_limit=discount_upper_limit
            )
        results[discount_upper_limit] = {
            "profits": dynamic_results,
            "total_profit": total_profit
        }
        print(f"折扣上限 {discount_upper_limit:.2f} 的總利潤: {total_profit:.2f}")

    best_discount = max(results, key=lambda k: results[k]["total_profit"])
    best_profit = results[best_discount]["total_profit"]

    print(f"\n最佳的折扣上限為 {best_discount:.2f}，其總利潤為 {best_profit:.2f}")

    return results, best_discount, best_profit

def plot_profit_vs_discount(results):
    discounts = sorted(results.keys())
    profits = [results[d]['total_profit'] for d in discounts]

    plt.figure(figsize=(10, 6))
    plt.plot(discounts, profits, marker='o')
    plt.title("Total Profit vs Discount Upper Bound")
    plt.xlabel("discount upper bound")
    plt.ylabel("Total Profit")
    plt.grid(True)
    plt.show()

def plot_price_and_sales(price_history, all_sales, daily_supplies, up_limit=None, down_limit=None, total_sales_limit=None):
    # 繪製價格走勢
    plt.figure(figsize=(12, 6))
    for drink, prices in price_history.items():
        plt.plot(prices, label=f"{drink} Price")

    if up_limit is not None:
        plt.axhline(y=up_limit, color='g', linestyle='--', label='Price Upper Limit')
    if down_limit is not None:
        plt.axhline(y=down_limit, color='b', linestyle='--', label='Price Lower Limit')

    plt.title("Price Changes Over Time (15-Minute Intervals)")
    plt.xlabel("Time Interval")
    plt.ylabel("Price")
    plt.legend(title="Legend", bbox_to_anchor=(1.05, 1), loc='upper left')
    plt.grid(True)
    plt.tight_layout()
    plt.show()

    # 計算每個時段的總銷售量
    max_length = max(len(sales) for sales in all_sales.values())
    padded_sales = np.array([
        np.pad(sales, (0, max_length - len(sales)), 'constant')
        for sales in all_sales.values()
    ])
    total_sales_per_period = np.sum(padded_sales, axis=0)

    # 繪製銷售量走勢
    plt.figure(figsize=(12, 6))
    plt.plot(total_sales_per_period, label="Total Sales Per Period", color='orange')
    if total_sales_limit is not None:
        plt.axhline(y=total_sales_limit, color='r', linestyle='--', label='Total Sales Limit')

    plt.title("Total Sales Over Time")
    plt.xlabel("Time Interval")
    plt.ylabel("Total Sales (ml)")
    plt.legend(loc='upper left')
    plt.grid(True)
    plt.tight_layout()
    plt.show()

n_days = 1
discount_upper_limits = np.linspace(0.1, 1.0, 10)

# 尋找最佳折扣上限
results, best_discount, best_profit = find_best_discount_upper_limit(
    n_days=n_days,
    time_slots_per_day=time_slots_per_day,
    parameter_mapping=parameter_mapping,
    cost_per_unit=cost_per_unit,
    initial_prices=initial_prices,
    discount_upper_limits=discount_upper_limits
)

# 計算平均每日利潤
average_daily_profit = best_profit / n_days
print(f"平均每日利潤: {average_daily_profit:.2f}")

# 繪製「總利潤 vs 折扣上限」
plot_profit_vs_discount(results)

# 使用最佳折扣上限重新模擬，查看詳細結果
dynamic_results, price_history, all_prices, all_demands, all_sales, daily_supplies, schedule, total_profit = \
    simulate_dynamic_pricing_with_discounts(
        n_days=n_days,
        time_slots_per_day=time_slots_per_day,
        parameter_mapping=parameter_mapping,
        cost_per_unit=cost_per_unit,
        initial_prices=initial_prices,
        discount_upper_limit=best_discount
    )

# 顯示各個飲料的詳細資訊
print("\n最佳折扣上限的模擬結果:")
for drink in DRINK_TYPES:
    total_sales_for_drink = sum(all_sales[drink])
    total_demand_for_drink = sum(all_demands[drink]) if len(all_demands[drink]) else 0
    total_profit_drink = dynamic_results[drink]
    print(f"{drink}:  "
          f"Total Sales={total_sales_for_drink:.2f} ml, "
          f"Total Demand={total_demand_for_drink:.2f} ml, "
          f"Total Profit={total_profit_drink:.2f}")

print(f"\n總利潤: {total_profit:.2f}")

# 繪製價格與銷售量變化圖
plot_price_and_sales(
    price_history,
    all_sales,
    daily_supplies,
    up_limit=UP_LIMIT,
    down_limit=DOWN_LIMIT
)

